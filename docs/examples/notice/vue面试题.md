# 理论

## 1. 对`Vue `渐进式框架的理解

- 渐进式的含义：主张最少, 没有多做职责之外的事

-  `Vue `有些方面是不如 `React`，不如 `Angular`,但它是渐进的，没有强主张， 你可以在原有系统的上面，把一两个组件改用它实现，当 `jQuery `用；

-  也可以整个用它全家桶开发，当 `Angular `用；还可以用它的视图，搭配你自己设计的整个下层用。

-  你可以在底层数据逻辑的地方用 `OO `和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。

## 2. vue 的双向绑定的原理

- 数据双向绑定是通过**数据劫持**结合**发布者**-**订阅者**模式的方式来实现的
- 具体实现流程：
  1. 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者
  2. 实现一个订阅者 Watcher，可将收到属性的变化通知并执行相应的函数， 从而更新视图
  3. 实现一个解析器 Compile，扫描和解析每个节点的相关指令，根据初始化模板数据以及初始化相应的订阅器



![image-20221020150333812](https://c-typora.oss-cn-guangzhou.aliyuncs.com/c-typora/image-20221020150333812.png)

## 3. 虚拟 DOM

虚拟 `DOM `(Virtual DOM，简称 `VDOM`) 是一种编程概念，意为将目标所需的 `UI `通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。

## 4. Key 的作用是什么？可以用数组的 index（下标）代替么？

- key 的作用主要是为了高效的更新虚拟DOM
- `vue `中在使用相同标签名元素的过渡切换时，也会使用到`key `属性，其目的也是为了让`vue `可以区分它们。否则`vue `只会替换其内部属性而不会触发过渡效果
- `key `不能用 `index `代替，`index `在同一个页面会有重复的情况，违背了高效渲染的初衷

## 5. `Vue `组件中 data 为什么必须是函数？

- 在 `new Vue()` ， data 是可以作为一个对象进行操作的，然而在 component 中，data 只能**以函数**的形式存在，不能直接将对象赋值给它
- 当data 选项是一个函数的时候，每个实例可以维护一份返回独立的拷贝对象，这样各个实例中的data 不会相互影响，是独立的

## 6. $route 和 $router 的区别是什么？

- `$router` 为`VueRouter` 的实例，是一个全局路由对象，包含了`路由跳转`的方法、`钩子函数`等。

- `$route `是`路由信息`对象或者跳转的路由对象，每一个路由都会有一个 route 对象，是一个局部对象，包含 `path`，`params`，`hash`，`query`，`fullPath`，`matched`， `name `等路由信息参数。

## 7. 为什么要用Proxy API 替代defineProperty API？

- `defineProperty `的局限性的最大原因是它只能`针对单例属性`做监听，`Vue2.x`中对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 `Vue `只能对 data 中预定义过的属性做出响应的原因。

- `Proxy `的监听是`针对对象`的，那么对这个对象的所有操作会进入监听操作， 这就完全可以`代理所有属性`，将会带来很大的性能提升和更优的代码。

## 8.Vue3.0编译做了哪些优化？

- 生成block-tree

  i. `Vue.js 2.x` 的数据更新并触发重新渲染的粒度是`组件级`的，单个组件内部需要`遍历`该组件的整个 `vnode `树。

  ii. `Vue.js 3.0` 做到了通过编译阶段对静态模板的分析，编译生成了 `Blocktree`。`Block tree` 是一个将模版`基于动态节点`指令切割的嵌套区块，每个区块内部的节点结构是固定的。每个区块只需要追踪自身包含的动态节点。

- slot 编译优化

  i. `Vue.js 2.x` 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使子组件 update，造成性能的浪费。

  ii. `Vue.js 3.0 `优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字等会导致 slot 产生运行时动态变化但是又无法被子组件 track 的操作。

## 9. Vue数据响应式与双向数据绑定原理区分

- `数据响应式`是指通过数据驱动DOM视图的变化，是**单向**的过程,`双向数据绑定`的数据和DOM是一个**双向**的关系
- 数据响应式是`数据驱动视图更新`,双向绑定是`数据和视图相互驱动更新`

## 10. vue中MVVM的理解

**M：模型（Model）**：数据模型；负责数据存储。泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。

**V：视图(View )：** 负责页面展示，也就是用户界面。主要由 `HTML `和 `CSS `来构建

**VM：视图模型（View-Model）：** 负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示
通过`vue`类创建的对象叫`Vue`实例化对象，这个对象就是`MVVM`模式中的`VM`层，模型通过它可以将数据绑定到页面上，视图可以通过它将数据映射到模型上

**优点**

1. 低耦合：视图（View）可以独立于Model变化和修改
2. 可重用性：你可以把一些视图逻辑放在一个`ViewModel`里面，让很多view重用这段视图逻辑
3. 前后端分离，开发人员可以专注于业务逻辑（`ViewModel`）和数据的开发，设计人员可以专注于页面设计

## 11. vue生命周期

`Vue `实例从创建到销毁的过程，就是生命周期。从开始**创建**、**初始化**数据、**编译**模板、**挂载**Dom→**渲染**、**更新**→**渲染**、**销毁**等一系列过程，称之为 `Vue `的生命周期。

- `beforeCreate`（创建前） ：组件实例被创建之初，组件的属性生效之前,`beforeCreate`生命周期执行的时候，data和methods中的数据都**还没有**初始化。不能在这个阶段使用data中的数据和methods中的方法 

- `created`（创建后） ：组件实例已经完全创建，属性也绑定，但真实 `dom `还没有生成，`$el` 还不可用, data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作

- `beforeMount`（挂载前） ：在挂载开始之前被调用：相关的 `render `函数首次被调用;执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的

- `mounted`（挂载后） ：在el 被新创建的 `vm.$el` 替换，并挂载到实例上去之后调用该钩子;`Vue`实例已经初始化完成了,如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行

- `beforeUpdate`（更新前） ：组件数据更新之前调用，真实DOM还没被渲染;*页面中的显示的数据还是旧的，data中的数据是更新后的，页面还没有和最新的数据保持同步*

- `update`（更新后） ：组件数据更新之后;*页面显示的数据和data中的数据已经保持同步了，都是最新的*

- `activated`（激活前） ：**keep-alive专属**，组件被激活时调用;*当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。*
- `deactivated`（激活后） ：**keep-alive专属**，组件被销毁时调用

- `beforeDestory`（销毁前） ：组件销毁前调用;*这个时候所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁*
- `destoryed`（销毁后） ：组件销毁前调用

## 12. vue3的生命周期

**setup中的函数执行相当于在选项API中的`beforeCreate`和`created`中执行**

## 13. v-el 作用是什么

提供一个在页面上已存在的 `DOM `元素作为 `Vue `实例的挂载目标。可以是 `CSS `选择器，也可以是一个 `HTMLElement `实例。

## 14. Vue的el属性和$mount优先级？

```
new Vue({
  router,
  store,
  el: '#app',
  render: h => h(App)
}).$mount('#div')
/*当出现上面的情况就需要对el和$mount优先级进行判断，从下面的官方图片我们可以看出来，
el的优先级是高于$mount的，因此以el挂载节点为准*/
```

## 15. data里面的数据不想做响应式，该怎么做

- 数据放在`vue`实例外（`vue template`中访问不到数据）
- `created`, `mounted`钩子函数中定义(注意data中不要声明该变量名)
- `Object.freeze()`

## 16. 如何将获取data中某一个数据的初始状态？   

可以通过`this.$options.data().keyname`来获取初始值

```
data() {
    return {
      num: 10
  },
mounted() {
    this.num = 1000
  },
methods: {
    countNum() {
    	// 可以通过this.$options.data().keyname来获取初始值
        // 计算出num增加了多少
        console.log(1000 - this.$options.data().num)
    }
  }
```

## 17. 说几种如何实现vue首屏加载优化的

1. 把不常改变的库放到index.html中，通过cdn引入
2. vue路由的懒加载
3. vue组件尽量不要全局引入
4. 使用轻量级的工具库

## 18. 虚拟DOM实现原理

- 用JavaScript对象模拟真实DOM树，对真实DOM进行抽象
- `diff`算法：比较两棵虚拟树的差异
- `pach`算法：将两个虚拟DOM对象的差异应用到真实的DOM树

## 19. 简述原型与原型链，原型链的作用有哪些？

- 每一个类都**是**一个显示原型`prototype`
- 每一个类都**有**一个隐式原型`__proto__`
- 实例的`_proto__`等于类的显示原型`prototype`
- 当去查找一个实例的属性或方法，先在自身查找，找不到则沿着__`proto`__向上查找
- 我们把原型__`proto`__与原型__`proto`__形成的链条关系叫做原型链
- 作用是：实现了`js`的继承，让实列拥有了类的公用方法

## 20. 怎样理解Vue的单向数据流？

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原数据进行修改

## 21. Vuex解决了什么问题？

- 解决多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力
- 来自不同组件的行为需要变更同一状态

## 22. 什么时候用Vuex

- 需要构建一个中大型单页应用时，使用`Vuex`能更好地在组件外部管理状态

## 23. Vuex中状态存储在那里？怎么改变它

存储在state中，改变`Vuex`中的状态的唯一途径就是显式地提交(`commit`)`mutation`

## 24. Vue和JQuery的区别在哪？为什么放弃JQuery用Vue？

- `JQuery`是直接操作DOM，`Vue`不直接操作DOM，`Vue`的数据与视图是分开的，`Vue`只需要操作数据就行了
- 在操作DOM频繁的场景里，`JQuery`的操作DOM行为是频繁的，而`Vue`利用虚拟DOM的技术，大大提高了更新DOM时的性能
- `Vue`中不提倡直接操作DOM，开发者只需要把大部分精力放在 数据层面上
- `Vue`集成的一些库，大大提高开发效率，比如`Vuex`，`Router`

## 25. SSR优缺点？

优点：
    `SSR `有着更好的 `SEO`（搜索引擎优化）、并且首屏加载速度更快。

缺点：
    开发条件会受限制，服务器端渲染只支持 `beforeCreate `和 `created `两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 `Node.js` 的运行环境。服务器会有更大的负载需求。

## 26.Vue项目性能优化

- v-if 和v-for区分使用场景
- computed和method区分使用场景
- v-for遍历必须为item添加key，且避免同时使用vif
- 懒加载
- 事件的销毁
- 第三方模块按需导入
- SPA (单组件)页面采用keep-alive缓存组件
- 对于短时间的大量操作（缩放、滚动）使用防抖、节流函数
- 代码精简，去除 console ，可复用的方法、组件提取出来
- 不要写行内样式，避免dom重绘
- key保证唯一性
- v-if 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show
- 服务端渲染ssr

```
1. 比如在前公司，做的推款项目中，这是一个大的需求项目，它涉及到与其他业务线的上下游流通，留给开发的时间仅仅有不到一个月的时间（讲明需求背景，项目大小、开发时长、时间越小、说明压力越大）
2.为了能够合理利用有限的时间，完成项目的进度推进，时刻保持与后端开发进行沟通，制定出的项目排期及接口的定义（表现沟通能力）
3.在后端没有给接口的情况下，自己先根据原型把静态页面写出来，然后再进行mock数据，只要后面接口通了，再进行相关的微调（利用有限时间，做最高效的事）
4.在最后进行项目联调测试时，由于产品原型进行调整，但是没有及时通知到开发且调整范围也比较大，最后为了能够按期完成项目提测，利用加班或周末加班进行完成进度推进（表现变通及抗压能力）
5.由于项目时间紧急，所以在开发的过程中，也出现了数据展现不准确或提交表单时缺少相关字段，导致数据无法提交或上下游数据流不通，最后通过各个业务线测试反馈的问题及进行代码调试很快找出问题所在并及时修复（表现解决问题的能力）
```

## 27. Commonjs 总结

`Commonjs` 的特性如下：

- CommonJS 模块由 JS 运行时实现。
- CommonJs 是单个值导出，本质上导出的就是 exports 属性。
- CommonJS 是可以动态加载的，对每一个加载都存在缓存，可以有效的解决循环引用问题。
- CommonJS 模块同步加载并执行模块文件。

## 28. es module 总结

`Es module` 的特性如下：

- ES6 Module 静态的，不能放在块级作用域内，代码发生在编译时。
- ES6 Module 的值是动态绑定的，可以通过导出方法修改，可以直接访问修改结果。
- ES6 Module 可以导出多个属性和方法，可以单个导入导出，混合导入导出。
- ES6 模块提前加载并执行模块文件，
- ES6 Module 导入模块在严格模式下。
- ES6 Module 的特性可以很容易实现 Tree Shaking 和 Code Splitting。

## 29.浏览器兼容性

1. 不同的浏览器的标签默认margin和padding不同

   ```
   解决：在CSS里设置 *{margin：0；padding：0}
   ```

2. 块属性标签float后，margin不一致的问题

   ```
   解决：在float的标签控制样式下添加“display：inline”。
   ```

3. 图片默认有间距，几个img标签放在一起的时候，有些浏览器会有默认的间距，加了通配符清除也不起作用

   ```
   解决：使用float属性为img布局
   ```

4. 不通浏览器中，样式的初始化方式不一样，通过添加浏览器前缀

   ```
   -webkit-border-radius: 10px; /*谷歌浏览器*/
   -ms-border-radius: 10px;     /*IE浏览器*/
   -moz-border-radius: 10px;    /*火狐浏览器*/
   -o-border-radius: 10px;      /*欧朋浏览器*/
   border-radius: 10px; 
   ```

5. `JS`兼容性

- `IE11 `不支持箭头函数、不支持 `Set `和 `Map `数据结构（不报错）及 `Promise `对象，支持 `let `和 `const`，`IE10` 及以下不支持任何 `ES6 `语法。

  ```
  解决：如果要兼容IE浏览器的项目使用 ES5 语法或者使用 Babel 进行转换。
  ```

- `DOM `事件绑定,`IE8` 及 `IE8` 以下版本浏览器是用 `attachEvent()` 方法，而其他浏览器是` addEventListener() `方法

```
解决：判断 IE 浏览器版本，如果是 IE8 及以下 事件绑定则使用 attachEvent() 方法，注意 attachEvent() 方法的用法，第一个参数为“onclick” 而不是“click”。并且没有第三个参数。
```

- `window.event`获取的。并且获取目标元素的方法也不同，标准浏览器是`event.target`，而IE下是`event.srcElement`

## 谈谈你对Webpack的理解

- `webpack `是一个静态模块打包器，当 `webpack `处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 `bundle`。
